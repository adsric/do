#!/bin/bash

# -----------------------------------------------------------------------

__color_support() {

	if infocmp xterm-256color &> /dev/null; then
		export TERM="xterm-256color"
	fi

	# -------------------------------------------------------------------

	# Set LS_COLORS (GNU).
	#
	#  - `ls` displays colors if the `--color` option is passed.
	#
	#  - The actual colors are configured through the `LS_COLORS`
	#    environment variable (built-in defaults are used if this
	#    variable is not set).

	LS_COLORS=""

	LS_COLORS+="no=0;39:"   # Global default
	LS_COLORS+="di=0;36:"   # Directory
	LS_COLORS+="ex=0;32:"   # Executable file
	LS_COLORS+="fi=0;39:"    # File
	LS_COLORS+="ec=:"       # Non-filename text
	LS_COLORS+="mi=1;31:"   # Non-existent file pointed to by a symlink
	LS_COLORS+="ln=target:" # Symbolic link
	LS_COLORS+="or=31;01"   # Symbolic link pointing to a non-existent file

	export LS_COLORS

	# -------------------------------------------------------------------

	# Enable color support of ls

	if [ -x /usr/bin/dircolors ]; then

		if test -r ~/.dircolors; then
			eval "$(dircolors -b ~/.dircolors)"
		fi

		alias ls='ls --color=auto'
		alias grep='grep --color=auto'
		alias fgrep='fgrep --color=auto'
		alias egrep='egrep --color=auto'

	fi

}

# -----------------------------------------------------------------------

__git_prompt() {
	local branchName="";
	local git_arrows=""
	local change_summary=""

	# Check if the current directory is in a Git repository.
	if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == "0" ]; then

		if [ "$(git count-objects -v | grep size-pack | sed 's/size-pack: //')" -gt "500000" ]; then
			change_summary="\033[0;2;37m✗"
		else
			# check if the current directory is in .git before running git checks
			if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == "false" ]; then

				# Ensure the index is up to date.
				git update-index --really-refresh -q &>/dev/null;

				# Check upstream/downstream difference.
				local left="";
				local right="";
				if $(git rev-list --left-only --count HEAD...@'{u}' &>/dev/null); then
					left_output=$(git rev-list --left-only --count HEAD...@'{u}');
					if [ $left_output -gt 0 ]; then
						left="${left_output}⇡";
					fi
				fi

				if $(git rev-list --right-only --count HEAD...@'{u}' &>/dev/null); then
					right_output=$(git rev-list --right-only --count HEAD...@'{u}');
					if [ $right_output -gt 0 ]; then
						right="${right_output}⇣";
					fi
				fi

				if [ ! -z "$left" ]; then
					git_arrows+="\033[1;32m${left}"
				fi

				if [ ! -z "$right" ]; then
					git_arrows+="\033[1;31m${right}"
				fi

				if [ ! -z "$git_arrows" ]; then
					git_arrows="\033[1;30m[${git_arrows}\033[1;30m]"
				fi

				local file_summary_output=$(git diff --shortstat);
				local insertions=$(echo $file_summary_output | grep -o -E '([0-9]+ i)' | sed "s/ i//g");
				local deletions=$(echo $file_summary_output | grep -o -E '([0-9]+ d)' | sed "s/ d//g");

				if [ ! -z "$insertions" ]; then
					change_summary+="\033[0;2;32m+${insertions}"
					if [ ! -z "$deletions" ]; then
						change_summary+="\033[1;30m/"
					fi
				fi

				if [ ! -z "$deletions" ]; then
					change_summary+="\033[0;2;31m-${deletions}"
				fi

				# Check for untracked files.
				if [ -n "$(git ls-files --others --exclude-standard)" ]; then
					if [ ! -z "$insertions" ] || [ ! -z "$deletions" ]; then
						change_summary+="\033[1;30m/"
					fi
					change_summary+='\033[0;2;36m?';
				fi
			fi
		fi

		if [ ! -z "$change_summary" ]; then
			change_summary=" ${change_summary}\033[0m"
		fi

		# Get the short symbolic ref.
		# If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
		# Otherwise, just give up.
		branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
			git rev-parse --short HEAD 2> /dev/null || \
			echo '(unknown)')";

		echo -e " \033[1;33m@${branchName}${git_arrows}${change_summary}"
	else
		return;
	fi
}

# -----------------------------------------------------------------------

# What kind of session we use ? Local, Telnet, SSH

__set_connection() {
	if [[ -n "$SSH_CLIENT$SSH2_CLIENT" ]] ; then
		SESSION="\[\033[1;33m\]⚡\033[0m";
		SESSION+="\u@\h ";
	else
		local SESSION_SRC=$(who am i | sed -n 's/.*(\(.*\))/\1/p')
		if [[ -z "$SESSION_SRC" || "$SESSION_SRC" = ":"* ]] ; then
			SESSION="";
		else
			SESSION="\u@\h ";
		fi
	fi
}

# -----------------------------------------------------------------------

__prompt_command() {
	local LAST_EXIT=$?

	# set variable identifying the chroot you work in (used in the prompt below)
	if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
		debian_chroot=$(cat /etc/debian_chroot)
	fi

	__set_connection

	PS1="\n";
	PS1+="${debian_chroot:+($debian_chroot)}${SESSION}";
	PS1+="\[\033[01;34m\]\w\[\033[00m\]";
	PS1+="\$(__git_prompt)\033[0m";
	PS1+="\n";

	if [ $LAST_EXIT -eq 0 ]; then
		PS1+="\[\033[1;32m\]";
	else
		PS1+="\[\033[1;31m\]";
	fi

	# PS1 - Default interactive prompt
	PS1+="➜ \[\033[0m\]";

	# PS2 - Continuation interactive prompt
	PS2="⚡ "

}

# -----------------------------------------------------------------------

__set_prompt() {

	export PROMPT_COMMAND=__prompt_command  # Func to gen PS1 after CMDs

}

# -----------------------------------------------------------------------

main() {
	__color_support
	__set_prompt
}

main

# -----------------------------------------------------------------------

# Cleanup.

unset -f __color_support
unset -f __set_prompt
unset -f main
